# 问题

### reactivity

##### effect.ts

1. `ReactiveEffect` 的 `deps` 为什么是数组，不怕重复吗

   - 已解决（收集依赖时，判断 `dep` 是否收集过 `activeEffect`）

2. `stop` 方法调用之后，`activeEffect` 的 `active = false` 为什么不在 `track` 收集依赖的时候直接判断呢
   ![effect.ts](./%E5%9B%BE%E7%89%87/effect-2.png)

##### ref.ts

1. 触发 `set` 收集依赖时判断是否可以收集依赖 `isTracking` 放在了 `trackEffects` 中

   ![ref.ts](./%E5%9B%BE%E7%89%87/ref-1.png)
   ![effect.ts](./%E5%9B%BE%E7%89%87/ref-1-1.png)

##### 初始化流程

1. `initProps` 中 `props` 为什么设置为 `shallowReadonly` 会出现什么现象

# 收获

### reactivity

##### effect.ts

1. 副作用函数收集到依赖关系之后可以由 `scheduler` 来触发更新机制
2. 副作用函数 `watchEffect` 返回的 `StopHandle` 调用时，解除 `ReactiveEffect` 和 `dep` 依赖关系
3. 嵌套的对象，在初始化阶段并不会递归，只有在 `get` 的时候会重新调用 `reactive or readonly` 对子项进行加工

##### reactive.ts & ref.ts

1. `ref` 一个复杂对象时，会使用 `reactive` 包装， 而 `reactive` 一个单值时，则会抛出警告，并且失败
2. `ref` 在 `template` 中使用时不需要加 `.value` 是因为通过 `proxyRefs` 进行包装
   ![ref.ts](./%E5%9B%BE%E7%89%87/ref-2.png)

### runtime-core

##### 初始化流程

1. `createApp` -> 返回一个带有 `mount` 方法的对象
2. `mount` 方法接收一个容器，并把根组件创建成 `vnode`
3. 执行渲染方法 `render`
4. `render` 方法内部就是 `patch`
5. `patch` 方法会判断传入 `vnode` 类型， 执行 `processComponent or processElement`
6. `processComponent` 内部判断是否是更新流程， 不是的话执行 `mountComponent` 挂载流程
7. `mountComponent` 内部 -> 创建组件实例 `createComponentInstance` -> `setupComponent`
8. `setupComponent` 内部 `initProps` -> `initSlots` -> `setupStatefulComponent` 方法拿到 `setupState`
9. 给组件实例设置 `render`
10. 给组件设置代理
11. 注册事件
12. 实现 `initProps` 这里 `props` 是 `shallowReadonly`
    - 存在疑问

---
