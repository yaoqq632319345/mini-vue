# 问题

### reactivity

##### effect.ts

1. `ReactiveEffect` 的 `deps` 为什么是数组，不怕重复吗

   - 已解决（收集依赖时，判断 `dep` 是否收集过 `activeEffect`）

2. `stop` 方法调用之后，`activeEffect` 的 `active = false` 为什么不在 `track` 收集依赖的时候直接判断呢
   ![effect.ts](./%E5%9B%BE%E7%89%87/effect-2.png)

##### ref.ts

1. 触发 `set` 收集依赖时判断是否可以收集依赖 `isTracking` 放在了 `trackEffects` 中
   ![ref.ts](./%E5%9B%BE%E7%89%87/ref-1.png)
   ![effect.ts](./%E5%9B%BE%E7%89%87/ref-1-1.png)

# 收获

### reactivity

##### effect.ts

1. 副作用函数收集到依赖关系之后可以由 `scheduler` 来触发更新机制
2. 副作用函数 `watchEffect` 返回的 `StopHandle` 调用时，解除 `ReactiveEffect` 和 `dep` 依赖关系
3. 嵌套的对象，在初始化阶段并不会递归，只有在 `get` 的时候会重新调用 `reactive or readonly` 对子项进行加工

##### reactive.ts & ref.ts

1. `ref` 一个复杂对象时，会使用 `reactive` 包装， 而 `reactive` 一个单值时，则会抛出警告，并且失败
2. `ref` 在 `template` 中使用时不需要加 `.value` 是因为通过 `proxyRefs` 进行包装
   ![ref.ts](./%E5%9B%BE%E7%89%87/ref-2.png)
